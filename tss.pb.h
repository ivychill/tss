// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tss.proto

#ifndef PROTOBUF_tss_2eproto__INCLUDED
#define PROTOBUF_tss_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tss {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tss_2eproto();
void protobuf_AssignDesc_tss_2eproto();
void protobuf_ShutdownFile_tss_2eproto();

class LYCoordinate;
class LYLocation;
class LYSegment;
class LYRoute;
class LYSegmentTraffic;
class LYRoadTraffic;
class LYCityTraffic;
class LYCrontab;
class LYTrafficSub;
class LYTrafficPub;
class LYDeviceReport;
class LYCheckin;
class LYSamplePoint;
class LYTrafficReport;
class LYMsgOnAir;

enum LYCrontab_LYCronType {
  LYCrontab_LYCronType_LY_REP_MINUTE = 1,
  LYCrontab_LYCronType_LY_REP_HOUR = 2,
  LYCrontab_LYCronType_LY_REP_DOM = 4,
  LYCrontab_LYCronType_LY_REP_MONTH = 8,
  LYCrontab_LYCronType_LY_REP_DOW = 16
};
bool LYCrontab_LYCronType_IsValid(int value);
const LYCrontab_LYCronType LYCrontab_LYCronType_LYCronType_MIN = LYCrontab_LYCronType_LY_REP_MINUTE;
const LYCrontab_LYCronType LYCrontab_LYCronType_LYCronType_MAX = LYCrontab_LYCronType_LY_REP_DOW;
const int LYCrontab_LYCronType_LYCronType_ARRAYSIZE = LYCrontab_LYCronType_LYCronType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYCrontab_LYCronType_descriptor();
inline const ::std::string& LYCrontab_LYCronType_Name(LYCrontab_LYCronType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYCrontab_LYCronType_descriptor(), value);
}
inline bool LYCrontab_LYCronType_Parse(
    const ::std::string& name, LYCrontab_LYCronType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYCrontab_LYCronType>(
    LYCrontab_LYCronType_descriptor(), name, value);
}
enum LYTrafficSub_LYOprType {
  LYTrafficSub_LYOprType_LY_SUB_CREATE = 1,
  LYTrafficSub_LYOprType_LY_SUB_DELETE = 2,
  LYTrafficSub_LYOprType_LY_SUB_UPDATE = 3
};
bool LYTrafficSub_LYOprType_IsValid(int value);
const LYTrafficSub_LYOprType LYTrafficSub_LYOprType_LYOprType_MIN = LYTrafficSub_LYOprType_LY_SUB_CREATE;
const LYTrafficSub_LYOprType LYTrafficSub_LYOprType_LYOprType_MAX = LYTrafficSub_LYOprType_LY_SUB_UPDATE;
const int LYTrafficSub_LYOprType_LYOprType_ARRAYSIZE = LYTrafficSub_LYOprType_LYOprType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYTrafficSub_LYOprType_descriptor();
inline const ::std::string& LYTrafficSub_LYOprType_Name(LYTrafficSub_LYOprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYTrafficSub_LYOprType_descriptor(), value);
}
inline bool LYTrafficSub_LYOprType_Parse(
    const ::std::string& name, LYTrafficSub_LYOprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYTrafficSub_LYOprType>(
    LYTrafficSub_LYOprType_descriptor(), name, value);
}
enum LYTrafficSub_LYPubType {
  LYTrafficSub_LYPubType_LY_PUB_ADHOC = 1,
  LYTrafficSub_LYPubType_LY_PUB_EVENT = 2,
  LYTrafficSub_LYPubType_LY_PUB_CRON = 3
};
bool LYTrafficSub_LYPubType_IsValid(int value);
const LYTrafficSub_LYPubType LYTrafficSub_LYPubType_LYPubType_MIN = LYTrafficSub_LYPubType_LY_PUB_ADHOC;
const LYTrafficSub_LYPubType LYTrafficSub_LYPubType_LYPubType_MAX = LYTrafficSub_LYPubType_LY_PUB_CRON;
const int LYTrafficSub_LYPubType_LYPubType_ARRAYSIZE = LYTrafficSub_LYPubType_LYPubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYTrafficSub_LYPubType_descriptor();
inline const ::std::string& LYTrafficSub_LYPubType_Name(LYTrafficSub_LYPubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYTrafficSub_LYPubType_descriptor(), value);
}
inline bool LYTrafficSub_LYPubType_Parse(
    const ::std::string& name, LYTrafficSub_LYPubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYTrafficSub_LYPubType>(
    LYTrafficSub_LYPubType_descriptor(), name, value);
}
enum LYTrafficPub_LYPubType {
  LYTrafficPub_LYPubType_LY_PUB_ADHOC = 1,
  LYTrafficPub_LYPubType_LY_PUB_EVENT = 2,
  LYTrafficPub_LYPubType_LY_PUB_CRON = 3
};
bool LYTrafficPub_LYPubType_IsValid(int value);
const LYTrafficPub_LYPubType LYTrafficPub_LYPubType_LYPubType_MIN = LYTrafficPub_LYPubType_LY_PUB_ADHOC;
const LYTrafficPub_LYPubType LYTrafficPub_LYPubType_LYPubType_MAX = LYTrafficPub_LYPubType_LY_PUB_CRON;
const int LYTrafficPub_LYPubType_LYPubType_ARRAYSIZE = LYTrafficPub_LYPubType_LYPubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYTrafficPub_LYPubType_descriptor();
inline const ::std::string& LYTrafficPub_LYPubType_Name(LYTrafficPub_LYPubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYTrafficPub_LYPubType_descriptor(), value);
}
inline bool LYTrafficPub_LYPubType_Parse(
    const ::std::string& name, LYTrafficPub_LYPubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYTrafficPub_LYPubType>(
    LYTrafficPub_LYPubType_descriptor(), name, value);
}
enum LYOsType {
  LY_ANDROID = 0,
  LY_IOS = 1,
  LY_WP = 2
};
bool LYOsType_IsValid(int value);
const LYOsType LYOsType_MIN = LY_ANDROID;
const LYOsType LYOsType_MAX = LY_WP;
const int LYOsType_ARRAYSIZE = LYOsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYOsType_descriptor();
inline const ::std::string& LYOsType_Name(LYOsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYOsType_descriptor(), value);
}
inline bool LYOsType_Parse(
    const ::std::string& name, LYOsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYOsType>(
    LYOsType_descriptor(), name, value);
}
enum LYDirection {
  LY_UNKNOWN = 0,
  LY_EAST = 1,
  LY_NORTHEAST = 2,
  LY_NORTH = 3,
  LY_NORTHWEST = 4,
  LY_WEST = 5,
  LY_SOUTHWEST = 6,
  LY_SOUTH = 7,
  LY_SOUTHEAST = 8
};
bool LYDirection_IsValid(int value);
const LYDirection LYDirection_MIN = LY_UNKNOWN;
const LYDirection LYDirection_MAX = LY_SOUTHEAST;
const int LYDirection_ARRAYSIZE = LYDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYDirection_descriptor();
inline const ::std::string& LYDirection_Name(LYDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYDirection_descriptor(), value);
}
inline bool LYDirection_Parse(
    const ::std::string& name, LYDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYDirection>(
    LYDirection_descriptor(), name, value);
}
enum LYRetCode {
  LY_SUCCESS = 0,
  LY_VERSION_IMCOMPATIBLE = 273,
  LY_VERSION_LOW = 291,
  LY_PARTY_ERROR = 553,
  LY_MSG_TYPE_ERROR = 914,
  LY_TIMEOUT = 1171,
  LY_OTHER_ERROR = 2457
};
bool LYRetCode_IsValid(int value);
const LYRetCode LYRetCode_MIN = LY_SUCCESS;
const LYRetCode LYRetCode_MAX = LY_OTHER_ERROR;
const int LYRetCode_ARRAYSIZE = LYRetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYRetCode_descriptor();
inline const ::std::string& LYRetCode_Name(LYRetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYRetCode_descriptor(), value);
}
inline bool LYRetCode_Parse(
    const ::std::string& name, LYRetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYRetCode>(
    LYRetCode_descriptor(), name, value);
}
enum LYParty {
  LY_CLIENT = 1,
  LY_TSS = 2,
  LY_TC = 3
};
bool LYParty_IsValid(int value);
const LYParty LYParty_MIN = LY_CLIENT;
const LYParty LYParty_MAX = LY_TC;
const int LYParty_ARRAYSIZE = LYParty_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYParty_descriptor();
inline const ::std::string& LYParty_Name(LYParty value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYParty_descriptor(), value);
}
inline bool LYParty_Parse(
    const ::std::string& name, LYParty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYParty>(
    LYParty_descriptor(), name, value);
}
enum LYMsgType {
  LY_CHECKIN = 1,
  LY_RET_CODE = 2,
  LY_TRAFFIC_SUB = 4,
  LY_TRAFFIC_REPORT = 5,
  LY_DEVICE_REPORT = 6,
  LY_TRAFFIC_PUB = 19
};
bool LYMsgType_IsValid(int value);
const LYMsgType LYMsgType_MIN = LY_CHECKIN;
const LYMsgType LYMsgType_MAX = LY_TRAFFIC_PUB;
const int LYMsgType_ARRAYSIZE = LYMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LYMsgType_descriptor();
inline const ::std::string& LYMsgType_Name(LYMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LYMsgType_descriptor(), value);
}
inline bool LYMsgType_Parse(
    const ::std::string& name, LYMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LYMsgType>(
    LYMsgType_descriptor(), name, value);
}
// ===================================================================

class LYCoordinate : public ::google::protobuf::Message {
 public:
  LYCoordinate();
  virtual ~LYCoordinate();
  
  LYCoordinate(const LYCoordinate& from);
  
  inline LYCoordinate& operator=(const LYCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYCoordinate& default_instance();
  
  void Swap(LYCoordinate* other);
  
  // implements Message ----------------------------------------------
  
  LYCoordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYCoordinate& from);
  void MergeFrom(const LYCoordinate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double lng = 1;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 1;
  inline double lng() const;
  inline void set_lng(double value);
  
  // required double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);
  
  // @@protoc_insertion_point(class_scope:tss.LYCoordinate)
 private:
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double lng_;
  double lat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYCoordinate* default_instance_;
};
// -------------------------------------------------------------------

class LYLocation : public ::google::protobuf::Message {
 public:
  LYLocation();
  virtual ~LYLocation();
  
  LYLocation(const LYLocation& from);
  
  inline LYLocation& operator=(const LYLocation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYLocation& default_instance();
  
  void Swap(LYLocation* other);
  
  // implements Message ----------------------------------------------
  
  LYLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYLocation& from);
  void MergeFrom(const LYLocation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double lng = 1;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 1;
  inline double lng() const;
  inline void set_lng(double value);
  
  // required double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string adt = 11;
  inline bool has_adt() const;
  inline void clear_adt();
  static const int kAdtFieldNumber = 11;
  inline const ::std::string& adt() const;
  inline void set_adt(const ::std::string& value);
  inline void set_adt(const char* value);
  inline void set_adt(const char* value, size_t size);
  inline ::std::string* mutable_adt();
  inline ::std::string* release_adt();
  
  // @@protoc_insertion_point(class_scope:tss.LYLocation)
 private:
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_adt();
  inline void clear_has_adt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double lng_;
  double lat_;
  ::std::string* name_;
  ::std::string* adt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYLocation* default_instance_;
};
// -------------------------------------------------------------------

class LYSegment : public ::google::protobuf::Message {
 public:
  LYSegment();
  virtual ~LYSegment();
  
  LYSegment(const LYSegment& from);
  
  inline LYSegment& operator=(const LYSegment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYSegment& default_instance();
  
  void Swap(LYSegment* other);
  
  // implements Message ----------------------------------------------
  
  LYSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYSegment& from);
  void MergeFrom(const LYSegment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .tss.LYCoordinate start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::tss::LYCoordinate& start() const;
  inline ::tss::LYCoordinate* mutable_start();
  inline ::tss::LYCoordinate* release_start();
  
  // required .tss.LYCoordinate end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::tss::LYCoordinate& end() const;
  inline ::tss::LYCoordinate* mutable_end();
  inline ::tss::LYCoordinate* release_end();
  
  // optional string road = 3;
  inline bool has_road() const;
  inline void clear_road();
  static const int kRoadFieldNumber = 3;
  inline const ::std::string& road() const;
  inline void set_road(const ::std::string& value);
  inline void set_road(const char* value);
  inline void set_road(const char* value, size_t size);
  inline ::std::string* mutable_road();
  inline ::std::string* release_road();
  
  // @@protoc_insertion_point(class_scope:tss.LYSegment)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_road();
  inline void clear_has_road();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tss::LYCoordinate* start_;
  ::tss::LYCoordinate* end_;
  ::std::string* road_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYSegment* default_instance_;
};
// -------------------------------------------------------------------

class LYRoute : public ::google::protobuf::Message {
 public:
  LYRoute();
  virtual ~LYRoute();
  
  LYRoute(const LYRoute& from);
  
  inline LYRoute& operator=(const LYRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYRoute& default_instance();
  
  void Swap(LYRoute* other);
  
  // implements Message ----------------------------------------------
  
  LYRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYRoute& from);
  void MergeFrom(const LYRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline ::google::protobuf::int32 identity() const;
  inline void set_identity(::google::protobuf::int32 value);
  
  // repeated .tss.LYSegment segments = 2;
  inline int segments_size() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 2;
  inline const ::tss::LYSegment& segments(int index) const;
  inline ::tss::LYSegment* mutable_segments(int index);
  inline ::tss::LYSegment* add_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSegment >&
      segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::tss::LYSegment >*
      mutable_segments();
  
  // @@protoc_insertion_point(class_scope:tss.LYRoute)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tss::LYSegment > segments_;
  ::google::protobuf::int32 identity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYRoute* default_instance_;
};
// -------------------------------------------------------------------

class LYSegmentTraffic : public ::google::protobuf::Message {
 public:
  LYSegmentTraffic();
  virtual ~LYSegmentTraffic();
  
  LYSegmentTraffic(const LYSegmentTraffic& from);
  
  inline LYSegmentTraffic& operator=(const LYSegmentTraffic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYSegmentTraffic& default_instance();
  
  void Swap(LYSegmentTraffic* other);
  
  // implements Message ----------------------------------------------
  
  LYSegmentTraffic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYSegmentTraffic& from);
  void MergeFrom(const LYSegmentTraffic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .tss.LYSegment segment = 1;
  inline bool has_segment() const;
  inline void clear_segment();
  static const int kSegmentFieldNumber = 1;
  inline const ::tss::LYSegment& segment() const;
  inline ::tss::LYSegment* mutable_segment();
  inline ::tss::LYSegment* release_segment();
  
  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // required .tss.LYDirection direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline tss::LYDirection direction() const;
  inline void set_direction(tss::LYDirection value);
  
  // required int32 speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);
  
  // optional string details = 11;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 11;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const char* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  
  // @@protoc_insertion_point(class_scope:tss.LYSegmentTraffic)
 private:
  inline void set_has_segment();
  inline void clear_has_segment();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_details();
  inline void clear_has_details();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tss::LYSegment* segment_;
  ::google::protobuf::int64 timestamp_;
  int direction_;
  ::google::protobuf::int32 speed_;
  ::std::string* details_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYSegmentTraffic* default_instance_;
};
// -------------------------------------------------------------------

class LYRoadTraffic : public ::google::protobuf::Message {
 public:
  LYRoadTraffic();
  virtual ~LYRoadTraffic();
  
  LYRoadTraffic(const LYRoadTraffic& from);
  
  inline LYRoadTraffic& operator=(const LYRoadTraffic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYRoadTraffic& default_instance();
  
  void Swap(LYRoadTraffic* other);
  
  // implements Message ----------------------------------------------
  
  LYRoadTraffic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYRoadTraffic& from);
  void MergeFrom(const LYRoadTraffic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string road = 1;
  inline bool has_road() const;
  inline void clear_road();
  static const int kRoadFieldNumber = 1;
  inline const ::std::string& road() const;
  inline void set_road(const ::std::string& value);
  inline void set_road(const char* value);
  inline void set_road(const char* value, size_t size);
  inline ::std::string* mutable_road();
  inline ::std::string* release_road();
  
  // optional int64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // repeated .tss.LYSegmentTraffic segment_traffics = 3;
  inline int segment_traffics_size() const;
  inline void clear_segment_traffics();
  static const int kSegmentTrafficsFieldNumber = 3;
  inline const ::tss::LYSegmentTraffic& segment_traffics(int index) const;
  inline ::tss::LYSegmentTraffic* mutable_segment_traffics(int index);
  inline ::tss::LYSegmentTraffic* add_segment_traffics();
  inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSegmentTraffic >&
      segment_traffics() const;
  inline ::google::protobuf::RepeatedPtrField< ::tss::LYSegmentTraffic >*
      mutable_segment_traffics();
  
  // optional string alias = 4;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 4;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  
  // optional string href = 12;
  inline bool has_href() const;
  inline void clear_href();
  static const int kHrefFieldNumber = 12;
  inline const ::std::string& href() const;
  inline void set_href(const ::std::string& value);
  inline void set_href(const char* value);
  inline void set_href(const char* value, size_t size);
  inline ::std::string* mutable_href();
  inline ::std::string* release_href();
  
  // optional string desc = 11;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 11;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // @@protoc_insertion_point(class_scope:tss.LYRoadTraffic)
 private:
  inline void set_has_road();
  inline void clear_has_road();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_href();
  inline void clear_has_href();
  inline void set_has_desc();
  inline void clear_has_desc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* road_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::tss::LYSegmentTraffic > segment_traffics_;
  ::std::string* alias_;
  ::std::string* href_;
  ::std::string* desc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYRoadTraffic* default_instance_;
};
// -------------------------------------------------------------------

class LYCityTraffic : public ::google::protobuf::Message {
 public:
  LYCityTraffic();
  virtual ~LYCityTraffic();
  
  LYCityTraffic(const LYCityTraffic& from);
  
  inline LYCityTraffic& operator=(const LYCityTraffic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYCityTraffic& default_instance();
  
  void Swap(LYCityTraffic* other);
  
  // implements Message ----------------------------------------------
  
  LYCityTraffic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYCityTraffic& from);
  void MergeFrom(const LYCityTraffic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string city = 1;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 1;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // optional int64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // repeated .tss.LYRoadTraffic road_traffics = 3;
  inline int road_traffics_size() const;
  inline void clear_road_traffics();
  static const int kRoadTrafficsFieldNumber = 3;
  inline const ::tss::LYRoadTraffic& road_traffics(int index) const;
  inline ::tss::LYRoadTraffic* mutable_road_traffics(int index);
  inline ::tss::LYRoadTraffic* add_road_traffics();
  inline const ::google::protobuf::RepeatedPtrField< ::tss::LYRoadTraffic >&
      road_traffics() const;
  inline ::google::protobuf::RepeatedPtrField< ::tss::LYRoadTraffic >*
      mutable_road_traffics();
  
  // @@protoc_insertion_point(class_scope:tss.LYCityTraffic)
 private:
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* city_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::tss::LYRoadTraffic > road_traffics_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYCityTraffic* default_instance_;
};
// -------------------------------------------------------------------

class LYCrontab : public ::google::protobuf::Message {
 public:
  LYCrontab();
  virtual ~LYCrontab();
  
  LYCrontab(const LYCrontab& from);
  
  inline LYCrontab& operator=(const LYCrontab& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYCrontab& default_instance();
  
  void Swap(LYCrontab* other);
  
  // implements Message ----------------------------------------------
  
  LYCrontab* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYCrontab& from);
  void MergeFrom(const LYCrontab& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LYCrontab_LYCronType LYCronType;
  static const LYCronType LY_REP_MINUTE = LYCrontab_LYCronType_LY_REP_MINUTE;
  static const LYCronType LY_REP_HOUR = LYCrontab_LYCronType_LY_REP_HOUR;
  static const LYCronType LY_REP_DOM = LYCrontab_LYCronType_LY_REP_DOM;
  static const LYCronType LY_REP_MONTH = LYCrontab_LYCronType_LY_REP_MONTH;
  static const LYCronType LY_REP_DOW = LYCrontab_LYCronType_LY_REP_DOW;
  static inline bool LYCronType_IsValid(int value) {
    return LYCrontab_LYCronType_IsValid(value);
  }
  static const LYCronType LYCronType_MIN =
    LYCrontab_LYCronType_LYCronType_MIN;
  static const LYCronType LYCronType_MAX =
    LYCrontab_LYCronType_LYCronType_MAX;
  static const int LYCronType_ARRAYSIZE =
    LYCrontab_LYCronType_LYCronType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LYCronType_descriptor() {
    return LYCrontab_LYCronType_descriptor();
  }
  static inline const ::std::string& LYCronType_Name(LYCronType value) {
    return LYCrontab_LYCronType_Name(value);
  }
  static inline bool LYCronType_Parse(const ::std::string& name,
      LYCronType* value) {
    return LYCrontab_LYCronType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .tss.LYCrontab.LYCronType cron_type = 1;
  inline bool has_cron_type() const;
  inline void clear_cron_type();
  static const int kCronTypeFieldNumber = 1;
  inline ::tss::LYCrontab_LYCronType cron_type() const;
  inline void set_cron_type(::tss::LYCrontab_LYCronType value);
  
  // optional int64 minute = 2;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 2;
  inline ::google::protobuf::int64 minute() const;
  inline void set_minute(::google::protobuf::int64 value);
  
  // optional int64 hour = 3;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 3;
  inline ::google::protobuf::int64 hour() const;
  inline void set_hour(::google::protobuf::int64 value);
  
  // optional int32 dom = 4;
  inline bool has_dom() const;
  inline void clear_dom();
  static const int kDomFieldNumber = 4;
  inline ::google::protobuf::int32 dom() const;
  inline void set_dom(::google::protobuf::int32 value);
  
  // optional int32 month = 5;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 5;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);
  
  // optional int32 dow = 6;
  inline bool has_dow() const;
  inline void clear_dow();
  static const int kDowFieldNumber = 6;
  inline ::google::protobuf::int32 dow() const;
  inline void set_dow(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:tss.LYCrontab)
 private:
  inline void set_has_cron_type();
  inline void clear_has_cron_type();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_dom();
  inline void clear_has_dom();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_dow();
  inline void clear_has_dow();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 minute_;
  int cron_type_;
  ::google::protobuf::int32 dom_;
  ::google::protobuf::int64 hour_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 dow_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYCrontab* default_instance_;
};
// -------------------------------------------------------------------

class LYTrafficSub : public ::google::protobuf::Message {
 public:
  LYTrafficSub();
  virtual ~LYTrafficSub();
  
  LYTrafficSub(const LYTrafficSub& from);
  
  inline LYTrafficSub& operator=(const LYTrafficSub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYTrafficSub& default_instance();
  
  void Swap(LYTrafficSub* other);
  
  // implements Message ----------------------------------------------
  
  LYTrafficSub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYTrafficSub& from);
  void MergeFrom(const LYTrafficSub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LYTrafficSub_LYOprType LYOprType;
  static const LYOprType LY_SUB_CREATE = LYTrafficSub_LYOprType_LY_SUB_CREATE;
  static const LYOprType LY_SUB_DELETE = LYTrafficSub_LYOprType_LY_SUB_DELETE;
  static const LYOprType LY_SUB_UPDATE = LYTrafficSub_LYOprType_LY_SUB_UPDATE;
  static inline bool LYOprType_IsValid(int value) {
    return LYTrafficSub_LYOprType_IsValid(value);
  }
  static const LYOprType LYOprType_MIN =
    LYTrafficSub_LYOprType_LYOprType_MIN;
  static const LYOprType LYOprType_MAX =
    LYTrafficSub_LYOprType_LYOprType_MAX;
  static const int LYOprType_ARRAYSIZE =
    LYTrafficSub_LYOprType_LYOprType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LYOprType_descriptor() {
    return LYTrafficSub_LYOprType_descriptor();
  }
  static inline const ::std::string& LYOprType_Name(LYOprType value) {
    return LYTrafficSub_LYOprType_Name(value);
  }
  static inline bool LYOprType_Parse(const ::std::string& name,
      LYOprType* value) {
    return LYTrafficSub_LYOprType_Parse(name, value);
  }
  
  typedef LYTrafficSub_LYPubType LYPubType;
  static const LYPubType LY_PUB_ADHOC = LYTrafficSub_LYPubType_LY_PUB_ADHOC;
  static const LYPubType LY_PUB_EVENT = LYTrafficSub_LYPubType_LY_PUB_EVENT;
  static const LYPubType LY_PUB_CRON = LYTrafficSub_LYPubType_LY_PUB_CRON;
  static inline bool LYPubType_IsValid(int value) {
    return LYTrafficSub_LYPubType_IsValid(value);
  }
  static const LYPubType LYPubType_MIN =
    LYTrafficSub_LYPubType_LYPubType_MIN;
  static const LYPubType LYPubType_MAX =
    LYTrafficSub_LYPubType_LYPubType_MAX;
  static const int LYPubType_ARRAYSIZE =
    LYTrafficSub_LYPubType_LYPubType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LYPubType_descriptor() {
    return LYTrafficSub_LYPubType_descriptor();
  }
  static inline const ::std::string& LYPubType_Name(LYPubType value) {
    return LYTrafficSub_LYPubType_Name(value);
  }
  static inline bool LYPubType_Parse(const ::std::string& name,
      LYPubType* value) {
    return LYTrafficSub_LYPubType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string city = 1;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 1;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // required .tss.LYRoute route = 2;
  inline bool has_route() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 2;
  inline const ::tss::LYRoute& route() const;
  inline ::tss::LYRoute* mutable_route();
  inline ::tss::LYRoute* release_route();
  
  // required .tss.LYTrafficSub.LYOprType opr_type = 3;
  inline bool has_opr_type() const;
  inline void clear_opr_type();
  static const int kOprTypeFieldNumber = 3;
  inline ::tss::LYTrafficSub_LYOprType opr_type() const;
  inline void set_opr_type(::tss::LYTrafficSub_LYOprType value);
  
  // required .tss.LYTrafficSub.LYPubType pub_type = 4;
  inline bool has_pub_type() const;
  inline void clear_pub_type();
  static const int kPubTypeFieldNumber = 4;
  inline ::tss::LYTrafficSub_LYPubType pub_type() const;
  inline void set_pub_type(::tss::LYTrafficSub_LYPubType value);
  
  // optional int32 expires = 5 [default = 30];
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 5;
  inline ::google::protobuf::int32 expires() const;
  inline void set_expires(::google::protobuf::int32 value);
  
  // optional .tss.LYCrontab cron_tab = 6;
  inline bool has_cron_tab() const;
  inline void clear_cron_tab();
  static const int kCronTabFieldNumber = 6;
  inline const ::tss::LYCrontab& cron_tab() const;
  inline ::tss::LYCrontab* mutable_cron_tab();
  inline ::tss::LYCrontab* release_cron_tab();
  
  // @@protoc_insertion_point(class_scope:tss.LYTrafficSub)
 private:
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_route();
  inline void clear_has_route();
  inline void set_has_opr_type();
  inline void clear_has_opr_type();
  inline void set_has_pub_type();
  inline void clear_has_pub_type();
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_cron_tab();
  inline void clear_has_cron_tab();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* city_;
  ::tss::LYRoute* route_;
  int opr_type_;
  int pub_type_;
  ::tss::LYCrontab* cron_tab_;
  ::google::protobuf::int32 expires_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYTrafficSub* default_instance_;
};
// -------------------------------------------------------------------

class LYTrafficPub : public ::google::protobuf::Message {
 public:
  LYTrafficPub();
  virtual ~LYTrafficPub();
  
  LYTrafficPub(const LYTrafficPub& from);
  
  inline LYTrafficPub& operator=(const LYTrafficPub& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYTrafficPub& default_instance();
  
  void Swap(LYTrafficPub* other);
  
  // implements Message ----------------------------------------------
  
  LYTrafficPub* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYTrafficPub& from);
  void MergeFrom(const LYTrafficPub& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LYTrafficPub_LYPubType LYPubType;
  static const LYPubType LY_PUB_ADHOC = LYTrafficPub_LYPubType_LY_PUB_ADHOC;
  static const LYPubType LY_PUB_EVENT = LYTrafficPub_LYPubType_LY_PUB_EVENT;
  static const LYPubType LY_PUB_CRON = LYTrafficPub_LYPubType_LY_PUB_CRON;
  static inline bool LYPubType_IsValid(int value) {
    return LYTrafficPub_LYPubType_IsValid(value);
  }
  static const LYPubType LYPubType_MIN =
    LYTrafficPub_LYPubType_LYPubType_MIN;
  static const LYPubType LYPubType_MAX =
    LYTrafficPub_LYPubType_LYPubType_MAX;
  static const int LYPubType_ARRAYSIZE =
    LYTrafficPub_LYPubType_LYPubType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LYPubType_descriptor() {
    return LYTrafficPub_LYPubType_descriptor();
  }
  static inline const ::std::string& LYPubType_Name(LYPubType value) {
    return LYTrafficPub_LYPubType_Name(value);
  }
  static inline bool LYPubType_Parse(const ::std::string& name,
      LYPubType* value) {
    return LYTrafficPub_LYPubType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 route_id = 1;
  inline bool has_route_id() const;
  inline void clear_route_id();
  static const int kRouteIdFieldNumber = 1;
  inline ::google::protobuf::int32 route_id() const;
  inline void set_route_id(::google::protobuf::int32 value);
  
  // required .tss.LYCityTraffic city_traffic = 2;
  inline bool has_city_traffic() const;
  inline void clear_city_traffic();
  static const int kCityTrafficFieldNumber = 2;
  inline const ::tss::LYCityTraffic& city_traffic() const;
  inline ::tss::LYCityTraffic* mutable_city_traffic();
  inline ::tss::LYCityTraffic* release_city_traffic();
  
  // optional .tss.LYTrafficPub.LYPubType pub_type = 4;
  inline bool has_pub_type() const;
  inline void clear_pub_type();
  static const int kPubTypeFieldNumber = 4;
  inline ::tss::LYTrafficPub_LYPubType pub_type() const;
  inline void set_pub_type(::tss::LYTrafficPub_LYPubType value);
  
  // @@protoc_insertion_point(class_scope:tss.LYTrafficPub)
 private:
  inline void set_has_route_id();
  inline void clear_has_route_id();
  inline void set_has_city_traffic();
  inline void clear_has_city_traffic();
  inline void set_has_pub_type();
  inline void clear_has_pub_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tss::LYCityTraffic* city_traffic_;
  ::google::protobuf::int32 route_id_;
  int pub_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYTrafficPub* default_instance_;
};
// -------------------------------------------------------------------

class LYDeviceReport : public ::google::protobuf::Message {
 public:
  LYDeviceReport();
  virtual ~LYDeviceReport();
  
  LYDeviceReport(const LYDeviceReport& from);
  
  inline LYDeviceReport& operator=(const LYDeviceReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYDeviceReport& default_instance();
  
  void Swap(LYDeviceReport* other);
  
  // implements Message ----------------------------------------------
  
  LYDeviceReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYDeviceReport& from);
  void MergeFrom(const LYDeviceReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  
  // required bytes device_token = 2;
  inline bool has_device_token() const;
  inline void clear_device_token();
  static const int kDeviceTokenFieldNumber = 2;
  inline const ::std::string& device_token() const;
  inline void set_device_token(const ::std::string& value);
  inline void set_device_token(const char* value);
  inline void set_device_token(const void* value, size_t size);
  inline ::std::string* mutable_device_token();
  inline ::std::string* release_device_token();
  
  // required string device_name = 3;
  inline bool has_device_name() const;
  inline void clear_device_name();
  static const int kDeviceNameFieldNumber = 3;
  inline const ::std::string& device_name() const;
  inline void set_device_name(const ::std::string& value);
  inline void set_device_name(const char* value);
  inline void set_device_name(const char* value, size_t size);
  inline ::std::string* mutable_device_name();
  inline ::std::string* release_device_name();
  
  // required string device_model = 4;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 4;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  
  // required string device_os_version = 5;
  inline bool has_device_os_version() const;
  inline void clear_device_os_version();
  static const int kDeviceOsVersionFieldNumber = 5;
  inline const ::std::string& device_os_version() const;
  inline void set_device_os_version(const ::std::string& value);
  inline void set_device_os_version(const char* value);
  inline void set_device_os_version(const char* value, size_t size);
  inline ::std::string* mutable_device_os_version();
  inline ::std::string* release_device_os_version();
  
  // @@protoc_insertion_point(class_scope:tss.LYDeviceReport)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_device_token();
  inline void clear_has_device_token();
  inline void set_has_device_name();
  inline void clear_has_device_name();
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_device_os_version();
  inline void clear_has_device_os_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* device_id_;
  ::std::string* device_token_;
  ::std::string* device_name_;
  ::std::string* device_model_;
  ::std::string* device_os_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYDeviceReport* default_instance_;
};
// -------------------------------------------------------------------

class LYCheckin : public ::google::protobuf::Message {
 public:
  LYCheckin();
  virtual ~LYCheckin();
  
  LYCheckin(const LYCheckin& from);
  
  inline LYCheckin& operator=(const LYCheckin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYCheckin& default_instance();
  
  void Swap(LYCheckin* other);
  
  // implements Message ----------------------------------------------
  
  LYCheckin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYCheckin& from);
  void MergeFrom(const LYCheckin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string device_model = 1;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 1;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  
  // required .tss.LYOsType os_type = 2;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 2;
  inline tss::LYOsType os_type() const;
  inline void set_os_type(tss::LYOsType value);
  
  // optional string os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const char* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  
  // required int32 ly_major_release = 4;
  inline bool has_ly_major_release() const;
  inline void clear_ly_major_release();
  static const int kLyMajorReleaseFieldNumber = 4;
  inline ::google::protobuf::int32 ly_major_release() const;
  inline void set_ly_major_release(::google::protobuf::int32 value);
  
  // required int32 ly_minor_release = 5;
  inline bool has_ly_minor_release() const;
  inline void clear_ly_minor_release();
  static const int kLyMinorReleaseFieldNumber = 5;
  inline ::google::protobuf::int32 ly_minor_release() const;
  inline void set_ly_minor_release(::google::protobuf::int32 value);
  
  // optional string download_url = 6;
  inline bool has_download_url() const;
  inline void clear_download_url();
  static const int kDownloadUrlFieldNumber = 6;
  inline const ::std::string& download_url() const;
  inline void set_download_url(const ::std::string& value);
  inline void set_download_url(const char* value);
  inline void set_download_url(const char* value, size_t size);
  inline ::std::string* mutable_download_url();
  inline ::std::string* release_download_url();
  
  // optional string desc = 7;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 7;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // @@protoc_insertion_point(class_scope:tss.LYCheckin)
 private:
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_ly_major_release();
  inline void clear_has_ly_major_release();
  inline void set_has_ly_minor_release();
  inline void clear_has_ly_minor_release();
  inline void set_has_download_url();
  inline void clear_has_download_url();
  inline void set_has_desc();
  inline void clear_has_desc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* device_model_;
  ::std::string* os_version_;
  int os_type_;
  ::google::protobuf::int32 ly_major_release_;
  ::std::string* download_url_;
  ::std::string* desc_;
  ::google::protobuf::int32 ly_minor_release_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYCheckin* default_instance_;
};
// -------------------------------------------------------------------

class LYSamplePoint : public ::google::protobuf::Message {
 public:
  LYSamplePoint();
  virtual ~LYSamplePoint();
  
  LYSamplePoint(const LYSamplePoint& from);
  
  inline LYSamplePoint& operator=(const LYSamplePoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYSamplePoint& default_instance();
  
  void Swap(LYSamplePoint* other);
  
  // implements Message ----------------------------------------------
  
  LYSamplePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYSamplePoint& from);
  void MergeFrom(const LYSamplePoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .tss.LYCoordinate sp_coordinate = 1;
  inline bool has_sp_coordinate() const;
  inline void clear_sp_coordinate();
  static const int kSpCoordinateFieldNumber = 1;
  inline const ::tss::LYCoordinate& sp_coordinate() const;
  inline ::tss::LYCoordinate* mutable_sp_coordinate();
  inline ::tss::LYCoordinate* release_sp_coordinate();
  
  // required int64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // optional double altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline double altitude() const;
  inline void set_altitude(double value);
  
  // optional double course = 4;
  inline bool has_course() const;
  inline void clear_course();
  static const int kCourseFieldNumber = 4;
  inline double course() const;
  inline void set_course(double value);
  
  // @@protoc_insertion_point(class_scope:tss.LYSamplePoint)
 private:
  inline void set_has_sp_coordinate();
  inline void clear_has_sp_coordinate();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_course();
  inline void clear_has_course();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::tss::LYCoordinate* sp_coordinate_;
  ::google::protobuf::int64 timestamp_;
  double altitude_;
  double course_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYSamplePoint* default_instance_;
};
// -------------------------------------------------------------------

class LYTrafficReport : public ::google::protobuf::Message {
 public:
  LYTrafficReport();
  virtual ~LYTrafficReport();
  
  LYTrafficReport(const LYTrafficReport& from);
  
  inline LYTrafficReport& operator=(const LYTrafficReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYTrafficReport& default_instance();
  
  void Swap(LYTrafficReport* other);
  
  // implements Message ----------------------------------------------
  
  LYTrafficReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYTrafficReport& from);
  void MergeFrom(const LYTrafficReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tss.LYSamplePoint points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::tss::LYSamplePoint& points(int index) const;
  inline ::tss::LYSamplePoint* mutable_points(int index);
  inline ::tss::LYSamplePoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSamplePoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::tss::LYSamplePoint >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:tss.LYTrafficReport)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tss::LYSamplePoint > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYTrafficReport* default_instance_;
};
// -------------------------------------------------------------------

class LYMsgOnAir : public ::google::protobuf::Message {
 public:
  LYMsgOnAir();
  virtual ~LYMsgOnAir();
  
  LYMsgOnAir(const LYMsgOnAir& from);
  
  inline LYMsgOnAir& operator=(const LYMsgOnAir& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LYMsgOnAir& default_instance();
  
  void Swap(LYMsgOnAir* other);
  
  // implements Message ----------------------------------------------
  
  LYMsgOnAir* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LYMsgOnAir& from);
  void MergeFrom(const LYMsgOnAir& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required int32 msg_id = 5;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 5;
  inline ::google::protobuf::int32 msg_id() const;
  inline void set_msg_id(::google::protobuf::int32 value);
  
  // required int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // required .tss.LYParty from_party = 2;
  inline bool has_from_party() const;
  inline void clear_from_party();
  static const int kFromPartyFieldNumber = 2;
  inline tss::LYParty from_party() const;
  inline void set_from_party(tss::LYParty value);
  
  // required .tss.LYParty to_party = 3;
  inline bool has_to_party() const;
  inline void clear_to_party();
  static const int kToPartyFieldNumber = 3;
  inline tss::LYParty to_party() const;
  inline void set_to_party(tss::LYParty value);
  
  // required .tss.LYMsgType msg_type = 4;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 4;
  inline tss::LYMsgType msg_type() const;
  inline void set_msg_type(tss::LYMsgType value);
  
  // optional string snd_id = 7;
  inline bool has_snd_id() const;
  inline void clear_snd_id();
  static const int kSndIdFieldNumber = 7;
  inline const ::std::string& snd_id() const;
  inline void set_snd_id(const ::std::string& value);
  inline void set_snd_id(const char* value);
  inline void set_snd_id(const char* value, size_t size);
  inline ::std::string* mutable_snd_id();
  inline ::std::string* release_snd_id();
  
  // optional string rcv_id = 8;
  inline bool has_rcv_id() const;
  inline void clear_rcv_id();
  static const int kRcvIdFieldNumber = 8;
  inline const ::std::string& rcv_id() const;
  inline void set_rcv_id(const ::std::string& value);
  inline void set_rcv_id(const char* value);
  inline void set_rcv_id(const char* value, size_t size);
  inline ::std::string* mutable_rcv_id();
  inline ::std::string* release_rcv_id();
  
  // optional bytes signature = 9;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 9;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  
  // optional .tss.LYRetCode ret_code = 17;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 17;
  inline tss::LYRetCode ret_code() const;
  inline void set_ret_code(tss::LYRetCode value);
  
  // optional .tss.LYCheckin checkin = 18;
  inline bool has_checkin() const;
  inline void clear_checkin();
  static const int kCheckinFieldNumber = 18;
  inline const ::tss::LYCheckin& checkin() const;
  inline ::tss::LYCheckin* mutable_checkin();
  inline ::tss::LYCheckin* release_checkin();
  
  // optional .tss.LYDeviceReport device_report = 19;
  inline bool has_device_report() const;
  inline void clear_device_report();
  static const int kDeviceReportFieldNumber = 19;
  inline const ::tss::LYDeviceReport& device_report() const;
  inline ::tss::LYDeviceReport* mutable_device_report();
  inline ::tss::LYDeviceReport* release_device_report();
  
  // optional .tss.LYTrafficSub traffic_sub = 36;
  inline bool has_traffic_sub() const;
  inline void clear_traffic_sub();
  static const int kTrafficSubFieldNumber = 36;
  inline const ::tss::LYTrafficSub& traffic_sub() const;
  inline ::tss::LYTrafficSub* mutable_traffic_sub();
  inline ::tss::LYTrafficSub* release_traffic_sub();
  
  // optional .tss.LYTrafficPub traffic_pub = 51;
  inline bool has_traffic_pub() const;
  inline void clear_traffic_pub();
  static const int kTrafficPubFieldNumber = 51;
  inline const ::tss::LYTrafficPub& traffic_pub() const;
  inline ::tss::LYTrafficPub* mutable_traffic_pub();
  inline ::tss::LYTrafficPub* release_traffic_pub();
  
  // optional .tss.LYTrafficReport traffic_report = 65;
  inline bool has_traffic_report() const;
  inline void clear_traffic_report();
  static const int kTrafficReportFieldNumber = 65;
  inline const ::tss::LYTrafficReport& traffic_report() const;
  inline ::tss::LYTrafficReport* mutable_traffic_report();
  inline ::tss::LYTrafficReport* release_traffic_report();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LYMsgOnAir)
  // @@protoc_insertion_point(class_scope:tss.LYMsgOnAir)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_from_party();
  inline void clear_has_from_party();
  inline void set_has_to_party();
  inline void clear_has_to_party();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_snd_id();
  inline void clear_has_snd_id();
  inline void set_has_rcv_id();
  inline void clear_has_rcv_id();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_ret_code();
  inline void clear_has_ret_code();
  inline void set_has_checkin();
  inline void clear_has_checkin();
  inline void set_has_device_report();
  inline void clear_has_device_report();
  inline void set_has_traffic_sub();
  inline void clear_has_traffic_sub();
  inline void set_has_traffic_pub();
  inline void clear_has_traffic_pub();
  inline void set_has_traffic_report();
  inline void clear_has_traffic_report();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 msg_id_;
  ::google::protobuf::int64 timestamp_;
  int from_party_;
  int to_party_;
  ::std::string* snd_id_;
  ::std::string* rcv_id_;
  int msg_type_;
  int ret_code_;
  ::std::string* signature_;
  ::tss::LYCheckin* checkin_;
  ::tss::LYDeviceReport* device_report_;
  ::tss::LYTrafficSub* traffic_sub_;
  ::tss::LYTrafficPub* traffic_pub_;
  ::tss::LYTrafficReport* traffic_report_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_tss_2eproto();
  friend void protobuf_AssignDesc_tss_2eproto();
  friend void protobuf_ShutdownFile_tss_2eproto();
  
  void InitAsDefaultInstance();
  static LYMsgOnAir* default_instance_;
};
// ===================================================================


// ===================================================================

// LYCoordinate

// required double lng = 1;
inline bool LYCoordinate::has_lng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYCoordinate::set_has_lng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYCoordinate::clear_has_lng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYCoordinate::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double LYCoordinate::lng() const {
  return lng_;
}
inline void LYCoordinate::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// required double lat = 2;
inline bool LYCoordinate::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYCoordinate::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYCoordinate::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYCoordinate::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double LYCoordinate::lat() const {
  return lat_;
}
inline void LYCoordinate::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// -------------------------------------------------------------------

// LYLocation

// required double lng = 1;
inline bool LYLocation::has_lng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYLocation::set_has_lng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYLocation::clear_has_lng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYLocation::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double LYLocation::lng() const {
  return lng_;
}
inline void LYLocation::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// required double lat = 2;
inline bool LYLocation::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYLocation::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYLocation::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYLocation::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double LYLocation::lat() const {
  return lat_;
}
inline void LYLocation::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional string name = 3;
inline bool LYLocation::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYLocation::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYLocation::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYLocation::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LYLocation::name() const {
  return *name_;
}
inline void LYLocation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LYLocation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LYLocation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYLocation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LYLocation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string adt = 11;
inline bool LYLocation::has_adt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYLocation::set_has_adt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYLocation::clear_has_adt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYLocation::clear_adt() {
  if (adt_ != &::google::protobuf::internal::kEmptyString) {
    adt_->clear();
  }
  clear_has_adt();
}
inline const ::std::string& LYLocation::adt() const {
  return *adt_;
}
inline void LYLocation::set_adt(const ::std::string& value) {
  set_has_adt();
  if (adt_ == &::google::protobuf::internal::kEmptyString) {
    adt_ = new ::std::string;
  }
  adt_->assign(value);
}
inline void LYLocation::set_adt(const char* value) {
  set_has_adt();
  if (adt_ == &::google::protobuf::internal::kEmptyString) {
    adt_ = new ::std::string;
  }
  adt_->assign(value);
}
inline void LYLocation::set_adt(const char* value, size_t size) {
  set_has_adt();
  if (adt_ == &::google::protobuf::internal::kEmptyString) {
    adt_ = new ::std::string;
  }
  adt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYLocation::mutable_adt() {
  set_has_adt();
  if (adt_ == &::google::protobuf::internal::kEmptyString) {
    adt_ = new ::std::string;
  }
  return adt_;
}
inline ::std::string* LYLocation::release_adt() {
  clear_has_adt();
  if (adt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adt_;
    adt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYSegment

// required .tss.LYCoordinate start = 1;
inline bool LYSegment::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYSegment::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYSegment::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYSegment::clear_start() {
  if (start_ != NULL) start_->::tss::LYCoordinate::Clear();
  clear_has_start();
}
inline const ::tss::LYCoordinate& LYSegment::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::tss::LYCoordinate* LYSegment::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::tss::LYCoordinate;
  return start_;
}
inline ::tss::LYCoordinate* LYSegment::release_start() {
  clear_has_start();
  ::tss::LYCoordinate* temp = start_;
  start_ = NULL;
  return temp;
}

// required .tss.LYCoordinate end = 2;
inline bool LYSegment::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYSegment::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYSegment::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYSegment::clear_end() {
  if (end_ != NULL) end_->::tss::LYCoordinate::Clear();
  clear_has_end();
}
inline const ::tss::LYCoordinate& LYSegment::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::tss::LYCoordinate* LYSegment::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::tss::LYCoordinate;
  return end_;
}
inline ::tss::LYCoordinate* LYSegment::release_end() {
  clear_has_end();
  ::tss::LYCoordinate* temp = end_;
  end_ = NULL;
  return temp;
}

// optional string road = 3;
inline bool LYSegment::has_road() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYSegment::set_has_road() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYSegment::clear_has_road() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYSegment::clear_road() {
  if (road_ != &::google::protobuf::internal::kEmptyString) {
    road_->clear();
  }
  clear_has_road();
}
inline const ::std::string& LYSegment::road() const {
  return *road_;
}
inline void LYSegment::set_road(const ::std::string& value) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(value);
}
inline void LYSegment::set_road(const char* value) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(value);
}
inline void LYSegment::set_road(const char* value, size_t size) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYSegment::mutable_road() {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  return road_;
}
inline ::std::string* LYSegment::release_road() {
  clear_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = road_;
    road_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYRoute

// required int32 identity = 1;
inline bool LYRoute::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYRoute::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYRoute::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYRoute::clear_identity() {
  identity_ = 0;
  clear_has_identity();
}
inline ::google::protobuf::int32 LYRoute::identity() const {
  return identity_;
}
inline void LYRoute::set_identity(::google::protobuf::int32 value) {
  set_has_identity();
  identity_ = value;
}

// repeated .tss.LYSegment segments = 2;
inline int LYRoute::segments_size() const {
  return segments_.size();
}
inline void LYRoute::clear_segments() {
  segments_.Clear();
}
inline const ::tss::LYSegment& LYRoute::segments(int index) const {
  return segments_.Get(index);
}
inline ::tss::LYSegment* LYRoute::mutable_segments(int index) {
  return segments_.Mutable(index);
}
inline ::tss::LYSegment* LYRoute::add_segments() {
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSegment >&
LYRoute::segments() const {
  return segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::tss::LYSegment >*
LYRoute::mutable_segments() {
  return &segments_;
}

// -------------------------------------------------------------------

// LYSegmentTraffic

// required .tss.LYSegment segment = 1;
inline bool LYSegmentTraffic::has_segment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYSegmentTraffic::set_has_segment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYSegmentTraffic::clear_has_segment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYSegmentTraffic::clear_segment() {
  if (segment_ != NULL) segment_->::tss::LYSegment::Clear();
  clear_has_segment();
}
inline const ::tss::LYSegment& LYSegmentTraffic::segment() const {
  return segment_ != NULL ? *segment_ : *default_instance_->segment_;
}
inline ::tss::LYSegment* LYSegmentTraffic::mutable_segment() {
  set_has_segment();
  if (segment_ == NULL) segment_ = new ::tss::LYSegment;
  return segment_;
}
inline ::tss::LYSegment* LYSegmentTraffic::release_segment() {
  clear_has_segment();
  ::tss::LYSegment* temp = segment_;
  segment_ = NULL;
  return temp;
}

// optional int64 timestamp = 3;
inline bool LYSegmentTraffic::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYSegmentTraffic::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYSegmentTraffic::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYSegmentTraffic::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LYSegmentTraffic::timestamp() const {
  return timestamp_;
}
inline void LYSegmentTraffic::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .tss.LYDirection direction = 4;
inline bool LYSegmentTraffic::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYSegmentTraffic::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYSegmentTraffic::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYSegmentTraffic::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline tss::LYDirection LYSegmentTraffic::direction() const {
  return static_cast< tss::LYDirection >(direction_);
}
inline void LYSegmentTraffic::set_direction(tss::LYDirection value) {
  GOOGLE_DCHECK(tss::LYDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required int32 speed = 5;
inline bool LYSegmentTraffic::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYSegmentTraffic::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYSegmentTraffic::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYSegmentTraffic::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 LYSegmentTraffic::speed() const {
  return speed_;
}
inline void LYSegmentTraffic::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional string details = 11;
inline bool LYSegmentTraffic::has_details() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYSegmentTraffic::set_has_details() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYSegmentTraffic::clear_has_details() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYSegmentTraffic::clear_details() {
  if (details_ != &::google::protobuf::internal::kEmptyString) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& LYSegmentTraffic::details() const {
  return *details_;
}
inline void LYSegmentTraffic::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void LYSegmentTraffic::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void LYSegmentTraffic::set_details(const char* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYSegmentTraffic::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* LYSegmentTraffic::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYRoadTraffic

// required string road = 1;
inline bool LYRoadTraffic::has_road() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYRoadTraffic::set_has_road() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYRoadTraffic::clear_has_road() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYRoadTraffic::clear_road() {
  if (road_ != &::google::protobuf::internal::kEmptyString) {
    road_->clear();
  }
  clear_has_road();
}
inline const ::std::string& LYRoadTraffic::road() const {
  return *road_;
}
inline void LYRoadTraffic::set_road(const ::std::string& value) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(value);
}
inline void LYRoadTraffic::set_road(const char* value) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(value);
}
inline void LYRoadTraffic::set_road(const char* value, size_t size) {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  road_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYRoadTraffic::mutable_road() {
  set_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    road_ = new ::std::string;
  }
  return road_;
}
inline ::std::string* LYRoadTraffic::release_road() {
  clear_has_road();
  if (road_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = road_;
    road_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 timestamp = 2;
inline bool LYRoadTraffic::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYRoadTraffic::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYRoadTraffic::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYRoadTraffic::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LYRoadTraffic::timestamp() const {
  return timestamp_;
}
inline void LYRoadTraffic::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .tss.LYSegmentTraffic segment_traffics = 3;
inline int LYRoadTraffic::segment_traffics_size() const {
  return segment_traffics_.size();
}
inline void LYRoadTraffic::clear_segment_traffics() {
  segment_traffics_.Clear();
}
inline const ::tss::LYSegmentTraffic& LYRoadTraffic::segment_traffics(int index) const {
  return segment_traffics_.Get(index);
}
inline ::tss::LYSegmentTraffic* LYRoadTraffic::mutable_segment_traffics(int index) {
  return segment_traffics_.Mutable(index);
}
inline ::tss::LYSegmentTraffic* LYRoadTraffic::add_segment_traffics() {
  return segment_traffics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSegmentTraffic >&
LYRoadTraffic::segment_traffics() const {
  return segment_traffics_;
}
inline ::google::protobuf::RepeatedPtrField< ::tss::LYSegmentTraffic >*
LYRoadTraffic::mutable_segment_traffics() {
  return &segment_traffics_;
}

// optional string alias = 4;
inline bool LYRoadTraffic::has_alias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYRoadTraffic::set_has_alias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYRoadTraffic::clear_has_alias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYRoadTraffic::clear_alias() {
  if (alias_ != &::google::protobuf::internal::kEmptyString) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& LYRoadTraffic::alias() const {
  return *alias_;
}
inline void LYRoadTraffic::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void LYRoadTraffic::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
}
inline void LYRoadTraffic::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYRoadTraffic::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    alias_ = new ::std::string;
  }
  return alias_;
}
inline ::std::string* LYRoadTraffic::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string href = 12;
inline bool LYRoadTraffic::has_href() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYRoadTraffic::set_has_href() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYRoadTraffic::clear_has_href() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYRoadTraffic::clear_href() {
  if (href_ != &::google::protobuf::internal::kEmptyString) {
    href_->clear();
  }
  clear_has_href();
}
inline const ::std::string& LYRoadTraffic::href() const {
  return *href_;
}
inline void LYRoadTraffic::set_href(const ::std::string& value) {
  set_has_href();
  if (href_ == &::google::protobuf::internal::kEmptyString) {
    href_ = new ::std::string;
  }
  href_->assign(value);
}
inline void LYRoadTraffic::set_href(const char* value) {
  set_has_href();
  if (href_ == &::google::protobuf::internal::kEmptyString) {
    href_ = new ::std::string;
  }
  href_->assign(value);
}
inline void LYRoadTraffic::set_href(const char* value, size_t size) {
  set_has_href();
  if (href_ == &::google::protobuf::internal::kEmptyString) {
    href_ = new ::std::string;
  }
  href_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYRoadTraffic::mutable_href() {
  set_has_href();
  if (href_ == &::google::protobuf::internal::kEmptyString) {
    href_ = new ::std::string;
  }
  return href_;
}
inline ::std::string* LYRoadTraffic::release_href() {
  clear_has_href();
  if (href_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = href_;
    href_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 11;
inline bool LYRoadTraffic::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LYRoadTraffic::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LYRoadTraffic::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LYRoadTraffic::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& LYRoadTraffic::desc() const {
  return *desc_;
}
inline void LYRoadTraffic::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LYRoadTraffic::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LYRoadTraffic::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYRoadTraffic::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* LYRoadTraffic::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYCityTraffic

// optional string city = 1;
inline bool LYCityTraffic::has_city() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYCityTraffic::set_has_city() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYCityTraffic::clear_has_city() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYCityTraffic::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& LYCityTraffic::city() const {
  return *city_;
}
inline void LYCityTraffic::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LYCityTraffic::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LYCityTraffic::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYCityTraffic::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* LYCityTraffic::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 timestamp = 2;
inline bool LYCityTraffic::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYCityTraffic::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYCityTraffic::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYCityTraffic::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LYCityTraffic::timestamp() const {
  return timestamp_;
}
inline void LYCityTraffic::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .tss.LYRoadTraffic road_traffics = 3;
inline int LYCityTraffic::road_traffics_size() const {
  return road_traffics_.size();
}
inline void LYCityTraffic::clear_road_traffics() {
  road_traffics_.Clear();
}
inline const ::tss::LYRoadTraffic& LYCityTraffic::road_traffics(int index) const {
  return road_traffics_.Get(index);
}
inline ::tss::LYRoadTraffic* LYCityTraffic::mutable_road_traffics(int index) {
  return road_traffics_.Mutable(index);
}
inline ::tss::LYRoadTraffic* LYCityTraffic::add_road_traffics() {
  return road_traffics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tss::LYRoadTraffic >&
LYCityTraffic::road_traffics() const {
  return road_traffics_;
}
inline ::google::protobuf::RepeatedPtrField< ::tss::LYRoadTraffic >*
LYCityTraffic::mutable_road_traffics() {
  return &road_traffics_;
}

// -------------------------------------------------------------------

// LYCrontab

// required .tss.LYCrontab.LYCronType cron_type = 1;
inline bool LYCrontab::has_cron_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYCrontab::set_has_cron_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYCrontab::clear_has_cron_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYCrontab::clear_cron_type() {
  cron_type_ = 1;
  clear_has_cron_type();
}
inline ::tss::LYCrontab_LYCronType LYCrontab::cron_type() const {
  return static_cast< ::tss::LYCrontab_LYCronType >(cron_type_);
}
inline void LYCrontab::set_cron_type(::tss::LYCrontab_LYCronType value) {
  GOOGLE_DCHECK(::tss::LYCrontab_LYCronType_IsValid(value));
  set_has_cron_type();
  cron_type_ = value;
}

// optional int64 minute = 2;
inline bool LYCrontab::has_minute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYCrontab::set_has_minute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYCrontab::clear_has_minute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYCrontab::clear_minute() {
  minute_ = GOOGLE_LONGLONG(0);
  clear_has_minute();
}
inline ::google::protobuf::int64 LYCrontab::minute() const {
  return minute_;
}
inline void LYCrontab::set_minute(::google::protobuf::int64 value) {
  set_has_minute();
  minute_ = value;
}

// optional int64 hour = 3;
inline bool LYCrontab::has_hour() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYCrontab::set_has_hour() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYCrontab::clear_has_hour() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYCrontab::clear_hour() {
  hour_ = GOOGLE_LONGLONG(0);
  clear_has_hour();
}
inline ::google::protobuf::int64 LYCrontab::hour() const {
  return hour_;
}
inline void LYCrontab::set_hour(::google::protobuf::int64 value) {
  set_has_hour();
  hour_ = value;
}

// optional int32 dom = 4;
inline bool LYCrontab::has_dom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYCrontab::set_has_dom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYCrontab::clear_has_dom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYCrontab::clear_dom() {
  dom_ = 0;
  clear_has_dom();
}
inline ::google::protobuf::int32 LYCrontab::dom() const {
  return dom_;
}
inline void LYCrontab::set_dom(::google::protobuf::int32 value) {
  set_has_dom();
  dom_ = value;
}

// optional int32 month = 5;
inline bool LYCrontab::has_month() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYCrontab::set_has_month() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYCrontab::clear_has_month() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYCrontab::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 LYCrontab::month() const {
  return month_;
}
inline void LYCrontab::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
}

// optional int32 dow = 6;
inline bool LYCrontab::has_dow() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LYCrontab::set_has_dow() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LYCrontab::clear_has_dow() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LYCrontab::clear_dow() {
  dow_ = 0;
  clear_has_dow();
}
inline ::google::protobuf::int32 LYCrontab::dow() const {
  return dow_;
}
inline void LYCrontab::set_dow(::google::protobuf::int32 value) {
  set_has_dow();
  dow_ = value;
}

// -------------------------------------------------------------------

// LYTrafficSub

// required string city = 1;
inline bool LYTrafficSub::has_city() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYTrafficSub::set_has_city() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYTrafficSub::clear_has_city() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYTrafficSub::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& LYTrafficSub::city() const {
  return *city_;
}
inline void LYTrafficSub::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LYTrafficSub::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LYTrafficSub::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYTrafficSub::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* LYTrafficSub::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .tss.LYRoute route = 2;
inline bool LYTrafficSub::has_route() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYTrafficSub::set_has_route() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYTrafficSub::clear_has_route() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYTrafficSub::clear_route() {
  if (route_ != NULL) route_->::tss::LYRoute::Clear();
  clear_has_route();
}
inline const ::tss::LYRoute& LYTrafficSub::route() const {
  return route_ != NULL ? *route_ : *default_instance_->route_;
}
inline ::tss::LYRoute* LYTrafficSub::mutable_route() {
  set_has_route();
  if (route_ == NULL) route_ = new ::tss::LYRoute;
  return route_;
}
inline ::tss::LYRoute* LYTrafficSub::release_route() {
  clear_has_route();
  ::tss::LYRoute* temp = route_;
  route_ = NULL;
  return temp;
}

// required .tss.LYTrafficSub.LYOprType opr_type = 3;
inline bool LYTrafficSub::has_opr_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYTrafficSub::set_has_opr_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYTrafficSub::clear_has_opr_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYTrafficSub::clear_opr_type() {
  opr_type_ = 1;
  clear_has_opr_type();
}
inline ::tss::LYTrafficSub_LYOprType LYTrafficSub::opr_type() const {
  return static_cast< ::tss::LYTrafficSub_LYOprType >(opr_type_);
}
inline void LYTrafficSub::set_opr_type(::tss::LYTrafficSub_LYOprType value) {
  GOOGLE_DCHECK(::tss::LYTrafficSub_LYOprType_IsValid(value));
  set_has_opr_type();
  opr_type_ = value;
}

// required .tss.LYTrafficSub.LYPubType pub_type = 4;
inline bool LYTrafficSub::has_pub_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYTrafficSub::set_has_pub_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYTrafficSub::clear_has_pub_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYTrafficSub::clear_pub_type() {
  pub_type_ = 1;
  clear_has_pub_type();
}
inline ::tss::LYTrafficSub_LYPubType LYTrafficSub::pub_type() const {
  return static_cast< ::tss::LYTrafficSub_LYPubType >(pub_type_);
}
inline void LYTrafficSub::set_pub_type(::tss::LYTrafficSub_LYPubType value) {
  GOOGLE_DCHECK(::tss::LYTrafficSub_LYPubType_IsValid(value));
  set_has_pub_type();
  pub_type_ = value;
}

// optional int32 expires = 5 [default = 30];
inline bool LYTrafficSub::has_expires() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYTrafficSub::set_has_expires() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYTrafficSub::clear_has_expires() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYTrafficSub::clear_expires() {
  expires_ = 30;
  clear_has_expires();
}
inline ::google::protobuf::int32 LYTrafficSub::expires() const {
  return expires_;
}
inline void LYTrafficSub::set_expires(::google::protobuf::int32 value) {
  set_has_expires();
  expires_ = value;
}

// optional .tss.LYCrontab cron_tab = 6;
inline bool LYTrafficSub::has_cron_tab() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LYTrafficSub::set_has_cron_tab() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LYTrafficSub::clear_has_cron_tab() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LYTrafficSub::clear_cron_tab() {
  if (cron_tab_ != NULL) cron_tab_->::tss::LYCrontab::Clear();
  clear_has_cron_tab();
}
inline const ::tss::LYCrontab& LYTrafficSub::cron_tab() const {
  return cron_tab_ != NULL ? *cron_tab_ : *default_instance_->cron_tab_;
}
inline ::tss::LYCrontab* LYTrafficSub::mutable_cron_tab() {
  set_has_cron_tab();
  if (cron_tab_ == NULL) cron_tab_ = new ::tss::LYCrontab;
  return cron_tab_;
}
inline ::tss::LYCrontab* LYTrafficSub::release_cron_tab() {
  clear_has_cron_tab();
  ::tss::LYCrontab* temp = cron_tab_;
  cron_tab_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LYTrafficPub

// required int32 route_id = 1;
inline bool LYTrafficPub::has_route_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYTrafficPub::set_has_route_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYTrafficPub::clear_has_route_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYTrafficPub::clear_route_id() {
  route_id_ = 0;
  clear_has_route_id();
}
inline ::google::protobuf::int32 LYTrafficPub::route_id() const {
  return route_id_;
}
inline void LYTrafficPub::set_route_id(::google::protobuf::int32 value) {
  set_has_route_id();
  route_id_ = value;
}

// required .tss.LYCityTraffic city_traffic = 2;
inline bool LYTrafficPub::has_city_traffic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYTrafficPub::set_has_city_traffic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYTrafficPub::clear_has_city_traffic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYTrafficPub::clear_city_traffic() {
  if (city_traffic_ != NULL) city_traffic_->::tss::LYCityTraffic::Clear();
  clear_has_city_traffic();
}
inline const ::tss::LYCityTraffic& LYTrafficPub::city_traffic() const {
  return city_traffic_ != NULL ? *city_traffic_ : *default_instance_->city_traffic_;
}
inline ::tss::LYCityTraffic* LYTrafficPub::mutable_city_traffic() {
  set_has_city_traffic();
  if (city_traffic_ == NULL) city_traffic_ = new ::tss::LYCityTraffic;
  return city_traffic_;
}
inline ::tss::LYCityTraffic* LYTrafficPub::release_city_traffic() {
  clear_has_city_traffic();
  ::tss::LYCityTraffic* temp = city_traffic_;
  city_traffic_ = NULL;
  return temp;
}

// optional .tss.LYTrafficPub.LYPubType pub_type = 4;
inline bool LYTrafficPub::has_pub_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYTrafficPub::set_has_pub_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYTrafficPub::clear_has_pub_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYTrafficPub::clear_pub_type() {
  pub_type_ = 1;
  clear_has_pub_type();
}
inline ::tss::LYTrafficPub_LYPubType LYTrafficPub::pub_type() const {
  return static_cast< ::tss::LYTrafficPub_LYPubType >(pub_type_);
}
inline void LYTrafficPub::set_pub_type(::tss::LYTrafficPub_LYPubType value) {
  GOOGLE_DCHECK(::tss::LYTrafficPub_LYPubType_IsValid(value));
  set_has_pub_type();
  pub_type_ = value;
}

// -------------------------------------------------------------------

// LYDeviceReport

// required string device_id = 1;
inline bool LYDeviceReport::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYDeviceReport::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYDeviceReport::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYDeviceReport::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LYDeviceReport::device_id() const {
  return *device_id_;
}
inline void LYDeviceReport::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LYDeviceReport::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LYDeviceReport::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYDeviceReport::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LYDeviceReport::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes device_token = 2;
inline bool LYDeviceReport::has_device_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYDeviceReport::set_has_device_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYDeviceReport::clear_has_device_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYDeviceReport::clear_device_token() {
  if (device_token_ != &::google::protobuf::internal::kEmptyString) {
    device_token_->clear();
  }
  clear_has_device_token();
}
inline const ::std::string& LYDeviceReport::device_token() const {
  return *device_token_;
}
inline void LYDeviceReport::set_device_token(const ::std::string& value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
}
inline void LYDeviceReport::set_device_token(const char* value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
}
inline void LYDeviceReport::set_device_token(const void* value, size_t size) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYDeviceReport::mutable_device_token() {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  return device_token_;
}
inline ::std::string* LYDeviceReport::release_device_token() {
  clear_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_token_;
    device_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string device_name = 3;
inline bool LYDeviceReport::has_device_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYDeviceReport::set_has_device_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYDeviceReport::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYDeviceReport::clear_device_name() {
  if (device_name_ != &::google::protobuf::internal::kEmptyString) {
    device_name_->clear();
  }
  clear_has_device_name();
}
inline const ::std::string& LYDeviceReport::device_name() const {
  return *device_name_;
}
inline void LYDeviceReport::set_device_name(const ::std::string& value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void LYDeviceReport::set_device_name(const char* value) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(value);
}
inline void LYDeviceReport::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYDeviceReport::mutable_device_name() {
  set_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    device_name_ = new ::std::string;
  }
  return device_name_;
}
inline ::std::string* LYDeviceReport::release_device_name() {
  clear_has_device_name();
  if (device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_name_;
    device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string device_model = 4;
inline bool LYDeviceReport::has_device_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYDeviceReport::set_has_device_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYDeviceReport::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYDeviceReport::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& LYDeviceReport::device_model() const {
  return *device_model_;
}
inline void LYDeviceReport::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LYDeviceReport::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LYDeviceReport::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYDeviceReport::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* LYDeviceReport::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string device_os_version = 5;
inline bool LYDeviceReport::has_device_os_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYDeviceReport::set_has_device_os_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYDeviceReport::clear_has_device_os_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYDeviceReport::clear_device_os_version() {
  if (device_os_version_ != &::google::protobuf::internal::kEmptyString) {
    device_os_version_->clear();
  }
  clear_has_device_os_version();
}
inline const ::std::string& LYDeviceReport::device_os_version() const {
  return *device_os_version_;
}
inline void LYDeviceReport::set_device_os_version(const ::std::string& value) {
  set_has_device_os_version();
  if (device_os_version_ == &::google::protobuf::internal::kEmptyString) {
    device_os_version_ = new ::std::string;
  }
  device_os_version_->assign(value);
}
inline void LYDeviceReport::set_device_os_version(const char* value) {
  set_has_device_os_version();
  if (device_os_version_ == &::google::protobuf::internal::kEmptyString) {
    device_os_version_ = new ::std::string;
  }
  device_os_version_->assign(value);
}
inline void LYDeviceReport::set_device_os_version(const char* value, size_t size) {
  set_has_device_os_version();
  if (device_os_version_ == &::google::protobuf::internal::kEmptyString) {
    device_os_version_ = new ::std::string;
  }
  device_os_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYDeviceReport::mutable_device_os_version() {
  set_has_device_os_version();
  if (device_os_version_ == &::google::protobuf::internal::kEmptyString) {
    device_os_version_ = new ::std::string;
  }
  return device_os_version_;
}
inline ::std::string* LYDeviceReport::release_device_os_version() {
  clear_has_device_os_version();
  if (device_os_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_os_version_;
    device_os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYCheckin

// optional string device_model = 1;
inline bool LYCheckin::has_device_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYCheckin::set_has_device_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYCheckin::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYCheckin::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& LYCheckin::device_model() const {
  return *device_model_;
}
inline void LYCheckin::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LYCheckin::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void LYCheckin::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYCheckin::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* LYCheckin::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .tss.LYOsType os_type = 2;
inline bool LYCheckin::has_os_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYCheckin::set_has_os_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYCheckin::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYCheckin::clear_os_type() {
  os_type_ = 0;
  clear_has_os_type();
}
inline tss::LYOsType LYCheckin::os_type() const {
  return static_cast< tss::LYOsType >(os_type_);
}
inline void LYCheckin::set_os_type(tss::LYOsType value) {
  GOOGLE_DCHECK(tss::LYOsType_IsValid(value));
  set_has_os_type();
  os_type_ = value;
}

// optional string os_version = 3;
inline bool LYCheckin::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYCheckin::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYCheckin::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYCheckin::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::kEmptyString) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& LYCheckin::os_version() const {
  return *os_version_;
}
inline void LYCheckin::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::kEmptyString) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void LYCheckin::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::kEmptyString) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
}
inline void LYCheckin::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::kEmptyString) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYCheckin::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::kEmptyString) {
    os_version_ = new ::std::string;
  }
  return os_version_;
}
inline ::std::string* LYCheckin::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 ly_major_release = 4;
inline bool LYCheckin::has_ly_major_release() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYCheckin::set_has_ly_major_release() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYCheckin::clear_has_ly_major_release() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYCheckin::clear_ly_major_release() {
  ly_major_release_ = 0;
  clear_has_ly_major_release();
}
inline ::google::protobuf::int32 LYCheckin::ly_major_release() const {
  return ly_major_release_;
}
inline void LYCheckin::set_ly_major_release(::google::protobuf::int32 value) {
  set_has_ly_major_release();
  ly_major_release_ = value;
}

// required int32 ly_minor_release = 5;
inline bool LYCheckin::has_ly_minor_release() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYCheckin::set_has_ly_minor_release() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYCheckin::clear_has_ly_minor_release() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYCheckin::clear_ly_minor_release() {
  ly_minor_release_ = 0;
  clear_has_ly_minor_release();
}
inline ::google::protobuf::int32 LYCheckin::ly_minor_release() const {
  return ly_minor_release_;
}
inline void LYCheckin::set_ly_minor_release(::google::protobuf::int32 value) {
  set_has_ly_minor_release();
  ly_minor_release_ = value;
}

// optional string download_url = 6;
inline bool LYCheckin::has_download_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LYCheckin::set_has_download_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LYCheckin::clear_has_download_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LYCheckin::clear_download_url() {
  if (download_url_ != &::google::protobuf::internal::kEmptyString) {
    download_url_->clear();
  }
  clear_has_download_url();
}
inline const ::std::string& LYCheckin::download_url() const {
  return *download_url_;
}
inline void LYCheckin::set_download_url(const ::std::string& value) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(value);
}
inline void LYCheckin::set_download_url(const char* value) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(value);
}
inline void LYCheckin::set_download_url(const char* value, size_t size) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYCheckin::mutable_download_url() {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  return download_url_;
}
inline ::std::string* LYCheckin::release_download_url() {
  clear_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_url_;
    download_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 7;
inline bool LYCheckin::has_desc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LYCheckin::set_has_desc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LYCheckin::clear_has_desc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LYCheckin::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& LYCheckin::desc() const {
  return *desc_;
}
inline void LYCheckin::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LYCheckin::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LYCheckin::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYCheckin::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* LYCheckin::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LYSamplePoint

// required .tss.LYCoordinate sp_coordinate = 1;
inline bool LYSamplePoint::has_sp_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYSamplePoint::set_has_sp_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYSamplePoint::clear_has_sp_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYSamplePoint::clear_sp_coordinate() {
  if (sp_coordinate_ != NULL) sp_coordinate_->::tss::LYCoordinate::Clear();
  clear_has_sp_coordinate();
}
inline const ::tss::LYCoordinate& LYSamplePoint::sp_coordinate() const {
  return sp_coordinate_ != NULL ? *sp_coordinate_ : *default_instance_->sp_coordinate_;
}
inline ::tss::LYCoordinate* LYSamplePoint::mutable_sp_coordinate() {
  set_has_sp_coordinate();
  if (sp_coordinate_ == NULL) sp_coordinate_ = new ::tss::LYCoordinate;
  return sp_coordinate_;
}
inline ::tss::LYCoordinate* LYSamplePoint::release_sp_coordinate() {
  clear_has_sp_coordinate();
  ::tss::LYCoordinate* temp = sp_coordinate_;
  sp_coordinate_ = NULL;
  return temp;
}

// required int64 timestamp = 2;
inline bool LYSamplePoint::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYSamplePoint::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYSamplePoint::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYSamplePoint::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LYSamplePoint::timestamp() const {
  return timestamp_;
}
inline void LYSamplePoint::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double altitude = 3;
inline bool LYSamplePoint::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYSamplePoint::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYSamplePoint::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYSamplePoint::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double LYSamplePoint::altitude() const {
  return altitude_;
}
inline void LYSamplePoint::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// optional double course = 4;
inline bool LYSamplePoint::has_course() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYSamplePoint::set_has_course() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYSamplePoint::clear_has_course() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYSamplePoint::clear_course() {
  course_ = 0;
  clear_has_course();
}
inline double LYSamplePoint::course() const {
  return course_;
}
inline void LYSamplePoint::set_course(double value) {
  set_has_course();
  course_ = value;
}

// -------------------------------------------------------------------

// LYTrafficReport

// repeated .tss.LYSamplePoint points = 1;
inline int LYTrafficReport::points_size() const {
  return points_.size();
}
inline void LYTrafficReport::clear_points() {
  points_.Clear();
}
inline const ::tss::LYSamplePoint& LYTrafficReport::points(int index) const {
  return points_.Get(index);
}
inline ::tss::LYSamplePoint* LYTrafficReport::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::tss::LYSamplePoint* LYTrafficReport::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tss::LYSamplePoint >&
LYTrafficReport::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::tss::LYSamplePoint >*
LYTrafficReport::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// LYMsgOnAir

// required int32 version = 1;
inline bool LYMsgOnAir::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LYMsgOnAir::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LYMsgOnAir::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LYMsgOnAir::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 LYMsgOnAir::version() const {
  return version_;
}
inline void LYMsgOnAir::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required int32 msg_id = 5;
inline bool LYMsgOnAir::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LYMsgOnAir::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LYMsgOnAir::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LYMsgOnAir::clear_msg_id() {
  msg_id_ = 0;
  clear_has_msg_id();
}
inline ::google::protobuf::int32 LYMsgOnAir::msg_id() const {
  return msg_id_;
}
inline void LYMsgOnAir::set_msg_id(::google::protobuf::int32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required int64 timestamp = 6;
inline bool LYMsgOnAir::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LYMsgOnAir::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LYMsgOnAir::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LYMsgOnAir::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LYMsgOnAir::timestamp() const {
  return timestamp_;
}
inline void LYMsgOnAir::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .tss.LYParty from_party = 2;
inline bool LYMsgOnAir::has_from_party() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LYMsgOnAir::set_has_from_party() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LYMsgOnAir::clear_has_from_party() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LYMsgOnAir::clear_from_party() {
  from_party_ = 1;
  clear_has_from_party();
}
inline tss::LYParty LYMsgOnAir::from_party() const {
  return static_cast< tss::LYParty >(from_party_);
}
inline void LYMsgOnAir::set_from_party(tss::LYParty value) {
  GOOGLE_DCHECK(tss::LYParty_IsValid(value));
  set_has_from_party();
  from_party_ = value;
}

// required .tss.LYParty to_party = 3;
inline bool LYMsgOnAir::has_to_party() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LYMsgOnAir::set_has_to_party() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LYMsgOnAir::clear_has_to_party() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LYMsgOnAir::clear_to_party() {
  to_party_ = 1;
  clear_has_to_party();
}
inline tss::LYParty LYMsgOnAir::to_party() const {
  return static_cast< tss::LYParty >(to_party_);
}
inline void LYMsgOnAir::set_to_party(tss::LYParty value) {
  GOOGLE_DCHECK(tss::LYParty_IsValid(value));
  set_has_to_party();
  to_party_ = value;
}

// required .tss.LYMsgType msg_type = 4;
inline bool LYMsgOnAir::has_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LYMsgOnAir::set_has_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LYMsgOnAir::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LYMsgOnAir::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline tss::LYMsgType LYMsgOnAir::msg_type() const {
  return static_cast< tss::LYMsgType >(msg_type_);
}
inline void LYMsgOnAir::set_msg_type(tss::LYMsgType value) {
  GOOGLE_DCHECK(tss::LYMsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// optional string snd_id = 7;
inline bool LYMsgOnAir::has_snd_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LYMsgOnAir::set_has_snd_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LYMsgOnAir::clear_has_snd_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LYMsgOnAir::clear_snd_id() {
  if (snd_id_ != &::google::protobuf::internal::kEmptyString) {
    snd_id_->clear();
  }
  clear_has_snd_id();
}
inline const ::std::string& LYMsgOnAir::snd_id() const {
  return *snd_id_;
}
inline void LYMsgOnAir::set_snd_id(const ::std::string& value) {
  set_has_snd_id();
  if (snd_id_ == &::google::protobuf::internal::kEmptyString) {
    snd_id_ = new ::std::string;
  }
  snd_id_->assign(value);
}
inline void LYMsgOnAir::set_snd_id(const char* value) {
  set_has_snd_id();
  if (snd_id_ == &::google::protobuf::internal::kEmptyString) {
    snd_id_ = new ::std::string;
  }
  snd_id_->assign(value);
}
inline void LYMsgOnAir::set_snd_id(const char* value, size_t size) {
  set_has_snd_id();
  if (snd_id_ == &::google::protobuf::internal::kEmptyString) {
    snd_id_ = new ::std::string;
  }
  snd_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYMsgOnAir::mutable_snd_id() {
  set_has_snd_id();
  if (snd_id_ == &::google::protobuf::internal::kEmptyString) {
    snd_id_ = new ::std::string;
  }
  return snd_id_;
}
inline ::std::string* LYMsgOnAir::release_snd_id() {
  clear_has_snd_id();
  if (snd_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snd_id_;
    snd_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rcv_id = 8;
inline bool LYMsgOnAir::has_rcv_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LYMsgOnAir::set_has_rcv_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LYMsgOnAir::clear_has_rcv_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LYMsgOnAir::clear_rcv_id() {
  if (rcv_id_ != &::google::protobuf::internal::kEmptyString) {
    rcv_id_->clear();
  }
  clear_has_rcv_id();
}
inline const ::std::string& LYMsgOnAir::rcv_id() const {
  return *rcv_id_;
}
inline void LYMsgOnAir::set_rcv_id(const ::std::string& value) {
  set_has_rcv_id();
  if (rcv_id_ == &::google::protobuf::internal::kEmptyString) {
    rcv_id_ = new ::std::string;
  }
  rcv_id_->assign(value);
}
inline void LYMsgOnAir::set_rcv_id(const char* value) {
  set_has_rcv_id();
  if (rcv_id_ == &::google::protobuf::internal::kEmptyString) {
    rcv_id_ = new ::std::string;
  }
  rcv_id_->assign(value);
}
inline void LYMsgOnAir::set_rcv_id(const char* value, size_t size) {
  set_has_rcv_id();
  if (rcv_id_ == &::google::protobuf::internal::kEmptyString) {
    rcv_id_ = new ::std::string;
  }
  rcv_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYMsgOnAir::mutable_rcv_id() {
  set_has_rcv_id();
  if (rcv_id_ == &::google::protobuf::internal::kEmptyString) {
    rcv_id_ = new ::std::string;
  }
  return rcv_id_;
}
inline ::std::string* LYMsgOnAir::release_rcv_id() {
  clear_has_rcv_id();
  if (rcv_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcv_id_;
    rcv_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes signature = 9;
inline bool LYMsgOnAir::has_signature() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LYMsgOnAir::set_has_signature() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LYMsgOnAir::clear_has_signature() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LYMsgOnAir::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& LYMsgOnAir::signature() const {
  return *signature_;
}
inline void LYMsgOnAir::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void LYMsgOnAir::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void LYMsgOnAir::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LYMsgOnAir::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* LYMsgOnAir::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .tss.LYRetCode ret_code = 17;
inline bool LYMsgOnAir::has_ret_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LYMsgOnAir::set_has_ret_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LYMsgOnAir::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LYMsgOnAir::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline tss::LYRetCode LYMsgOnAir::ret_code() const {
  return static_cast< tss::LYRetCode >(ret_code_);
}
inline void LYMsgOnAir::set_ret_code(tss::LYRetCode value) {
  GOOGLE_DCHECK(tss::LYRetCode_IsValid(value));
  set_has_ret_code();
  ret_code_ = value;
}

// optional .tss.LYCheckin checkin = 18;
inline bool LYMsgOnAir::has_checkin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LYMsgOnAir::set_has_checkin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LYMsgOnAir::clear_has_checkin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LYMsgOnAir::clear_checkin() {
  if (checkin_ != NULL) checkin_->::tss::LYCheckin::Clear();
  clear_has_checkin();
}
inline const ::tss::LYCheckin& LYMsgOnAir::checkin() const {
  return checkin_ != NULL ? *checkin_ : *default_instance_->checkin_;
}
inline ::tss::LYCheckin* LYMsgOnAir::mutable_checkin() {
  set_has_checkin();
  if (checkin_ == NULL) checkin_ = new ::tss::LYCheckin;
  return checkin_;
}
inline ::tss::LYCheckin* LYMsgOnAir::release_checkin() {
  clear_has_checkin();
  ::tss::LYCheckin* temp = checkin_;
  checkin_ = NULL;
  return temp;
}

// optional .tss.LYDeviceReport device_report = 19;
inline bool LYMsgOnAir::has_device_report() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LYMsgOnAir::set_has_device_report() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LYMsgOnAir::clear_has_device_report() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LYMsgOnAir::clear_device_report() {
  if (device_report_ != NULL) device_report_->::tss::LYDeviceReport::Clear();
  clear_has_device_report();
}
inline const ::tss::LYDeviceReport& LYMsgOnAir::device_report() const {
  return device_report_ != NULL ? *device_report_ : *default_instance_->device_report_;
}
inline ::tss::LYDeviceReport* LYMsgOnAir::mutable_device_report() {
  set_has_device_report();
  if (device_report_ == NULL) device_report_ = new ::tss::LYDeviceReport;
  return device_report_;
}
inline ::tss::LYDeviceReport* LYMsgOnAir::release_device_report() {
  clear_has_device_report();
  ::tss::LYDeviceReport* temp = device_report_;
  device_report_ = NULL;
  return temp;
}

// optional .tss.LYTrafficSub traffic_sub = 36;
inline bool LYMsgOnAir::has_traffic_sub() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LYMsgOnAir::set_has_traffic_sub() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LYMsgOnAir::clear_has_traffic_sub() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LYMsgOnAir::clear_traffic_sub() {
  if (traffic_sub_ != NULL) traffic_sub_->::tss::LYTrafficSub::Clear();
  clear_has_traffic_sub();
}
inline const ::tss::LYTrafficSub& LYMsgOnAir::traffic_sub() const {
  return traffic_sub_ != NULL ? *traffic_sub_ : *default_instance_->traffic_sub_;
}
inline ::tss::LYTrafficSub* LYMsgOnAir::mutable_traffic_sub() {
  set_has_traffic_sub();
  if (traffic_sub_ == NULL) traffic_sub_ = new ::tss::LYTrafficSub;
  return traffic_sub_;
}
inline ::tss::LYTrafficSub* LYMsgOnAir::release_traffic_sub() {
  clear_has_traffic_sub();
  ::tss::LYTrafficSub* temp = traffic_sub_;
  traffic_sub_ = NULL;
  return temp;
}

// optional .tss.LYTrafficPub traffic_pub = 51;
inline bool LYMsgOnAir::has_traffic_pub() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LYMsgOnAir::set_has_traffic_pub() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LYMsgOnAir::clear_has_traffic_pub() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LYMsgOnAir::clear_traffic_pub() {
  if (traffic_pub_ != NULL) traffic_pub_->::tss::LYTrafficPub::Clear();
  clear_has_traffic_pub();
}
inline const ::tss::LYTrafficPub& LYMsgOnAir::traffic_pub() const {
  return traffic_pub_ != NULL ? *traffic_pub_ : *default_instance_->traffic_pub_;
}
inline ::tss::LYTrafficPub* LYMsgOnAir::mutable_traffic_pub() {
  set_has_traffic_pub();
  if (traffic_pub_ == NULL) traffic_pub_ = new ::tss::LYTrafficPub;
  return traffic_pub_;
}
inline ::tss::LYTrafficPub* LYMsgOnAir::release_traffic_pub() {
  clear_has_traffic_pub();
  ::tss::LYTrafficPub* temp = traffic_pub_;
  traffic_pub_ = NULL;
  return temp;
}

// optional .tss.LYTrafficReport traffic_report = 65;
inline bool LYMsgOnAir::has_traffic_report() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LYMsgOnAir::set_has_traffic_report() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LYMsgOnAir::clear_has_traffic_report() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LYMsgOnAir::clear_traffic_report() {
  if (traffic_report_ != NULL) traffic_report_->::tss::LYTrafficReport::Clear();
  clear_has_traffic_report();
}
inline const ::tss::LYTrafficReport& LYMsgOnAir::traffic_report() const {
  return traffic_report_ != NULL ? *traffic_report_ : *default_instance_->traffic_report_;
}
inline ::tss::LYTrafficReport* LYMsgOnAir::mutable_traffic_report() {
  set_has_traffic_report();
  if (traffic_report_ == NULL) traffic_report_ = new ::tss::LYTrafficReport;
  return traffic_report_;
}
inline ::tss::LYTrafficReport* LYMsgOnAir::release_traffic_report() {
  clear_has_traffic_report();
  ::tss::LYTrafficReport* temp = traffic_report_;
  traffic_report_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tss

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tss::LYCrontab_LYCronType>() {
  return ::tss::LYCrontab_LYCronType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tss::LYTrafficSub_LYOprType>() {
  return ::tss::LYTrafficSub_LYOprType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tss::LYTrafficSub_LYPubType>() {
  return ::tss::LYTrafficSub_LYPubType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tss::LYTrafficPub_LYPubType>() {
  return ::tss::LYTrafficPub_LYPubType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< tss::LYOsType>() {
  return tss::LYOsType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< tss::LYDirection>() {
  return tss::LYDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< tss::LYRetCode>() {
  return tss::LYRetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< tss::LYParty>() {
  return tss::LYParty_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< tss::LYMsgType>() {
  return tss::LYMsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tss_2eproto__INCLUDED
